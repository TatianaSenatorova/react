Что такое хук? Хук — это специальная функция, которая позволяет «подцепиться» к возможностям React. Например, хук useState предоставляет функциональным компонентам доступ к состоянию React.
Когда применить хук? Раньше, если вы писали функциональный компонент и осознавали, что вам нужно наделить его состоянием, вам приходилось превращать этот компонент в класс. Теперь же вы можете использовать хук внутри существующего функционального компонента.
Что делает вызов useState? Он объявляет «переменную состояния». Мы называли переменную count, но могли дать ей любое имя. Таким образом мы можем «сохранить» некоторые значения между вызовами функции.
Какие аргументы передавать useState? Единственный аргумент useState это исходное состояние.
Что возвращается из useState? Вызов useState вернёт пару значений: текущее состояние и функцию, обновляющую состояние.
Мы объявляем переменную состояния count и устанавливаем ей значение 0. React будет помнить текущее (наиболее свежее) значение между рендерингами и передавать его нашей функции. Если мы захотим изменить count, мы вызовем setCount.


<!-- import React, { useState } from 'react'
 Импортируем хук useState из React. Он позволяет функциональному компоненту хранить внутреннее состояние.

 Объявляем внутри компонента Example новую переменную состояния, вызвав хук useState. 

function Example() {
  const [count, setCount] = useState(0) -->

  <!-- return (
    <div>
      <p>Вы кликнули {count} раз(а)</p>
      Когда пользователь кликает по кнопке, мы вызываем setCount с приращённым значением. После этого React сделает повторный рендер, в котором использует уже новое значение count.
      <button onClick={() => setCount(count + 1)}>
        Нажми на меня
      </button>
    </div>
  )
} -->

Что же делает useEffect? Используя этот хук, вы говорите React сделать что-то после рендера. React запомнит функцию (то есть «эффект»), которую вы передали и вызовет её после того, как внесёт все изменения в DOM. В этом эффекте мы устанавливаем заголовок документа, но мы также можем выполнить запрос данных или вызвать какой-нибудь императивный API.
Почему же мы вызываем useEffect непосредственно внутри компонента? Это даёт нам доступ к переменной состояния count (или любым другим пропсам) прямиком из эффекта. Нам не нужен специальный API для доступа к этой переменной — она уже находится у нас в области видимости функции. Хуки используют JavaScript-замыкания, и таким образом, им не нужен специальный для React API, поскольку сам JavaScript уже имеет готовое решение для этой задачи.
<!-- import React, { useState, useEffect } from 'react'

function Example() {
  const [count, setCount] = useState(0)

  useEffect(() => {
    document.title = `Вы нажали ${count} раз`
  })

  return (
    <div>
      <p>Вы нажали {count} раз</p>
      <button onClick={() => setCount(count + 1)}>
        Нажми на меня
      </button>
    </div>
  )
} -->

useRef - это хук React, позволяющий ссылаться на значение, которое не нужно для рендеринга.
Используя реф-ссылку, вы гарантируете, что:

Вы можете сохранять информацию между повторными рендерами (в отличие от обычных переменных, которые сбрасываются при каждом рендере).
Ее изменение не вызывает повторного рендеринга (в отличие от переменных состояния, которые вызывают повторный рендеринг).
Информация является локальной для каждой копии вашего компонента (в отличие от внешних переменных, которые являются общими).